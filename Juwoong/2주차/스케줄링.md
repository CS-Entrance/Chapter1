# 스케줄링

태그: CS, 운영체제

# CPU 스케줄링

## CPU 스케줄링

스케줄링은 어떤 프로세스에게 CPU 자원을 할당할지 결정하는 과정입니다.

메모리에 올라온 프로세스들은 스케줄링 정책에 따라 CPU 자원을 할당받아 실행됩니다.

## 스케줄링 목적

스케줄링 목적은 CPU 자원을 최대한 잘 사용하는 것 입니다.

잘 사용하기 위해 고려해야할 성질은 다음과 같습니다.

| 공평성 | 모든 프로세스는 CPU 자원을 할당 받을 수 있어야 한다 |
| --- | --- |
| 효율성 | CPU 자원을 최대한 중단 없이 사용해야 한다 |
| 안정성 | 우선순위가 높은 프로세스를 먼저 처리해야 한다 |
| 반응시간 보장 | 일정 시간 이내에 프로세스 요구에 반응해야한다.  |
| 무한 연기 방지 | 특정 프로세스의 작업이 무한 연기 되어서는 안된다. |

## 스케줄링 단계

운영체제의 스케줄링은 작업 요청에 대해 프로세스 상태를 관리하며 실행 과정을 결정하는 것 입니다.

CPU 스케줄링은 전체 스케줄링 메커니즘의 일부입니다.

스케줄링은 관리 대상과 관리대상의 생명 주기에 따라 분류할 수 있습니다.
![스크린샷 2023-12-28 오전 8.31.28.png](..%2F..%2F..%2F..%2F..%2F..%2F..%2Fvar%2Ffolders%2Fj2%2Flq2fjw4n0rlby3mg4xddx_mh0000gn%2FT%2FTemporaryItems%2FNSIRD_screencaptureui_WzWify%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-28%20%EC%98%A4%EC%A0%84%208.31.28.png)

### 장기 스케줄링

디스크에서 메모리로 올릴 프로세스를 결정하는 과정 입니다.

디스크의 프로세스 큐에 있는 프로세스들을 선택해서 메모리로 올립니다.

메모리로 올려진 프로세스는 CPU 자원 할당을 기다리는 준비 큐에 들어갑니다.

작업 요청에 대한 실행 결정과 관련있으며 전체 프로세스 수를 관리합니다.

### 중기 스케줄링

메모리에 올라온 프로세스 중 디스크로 내릴 것과 메모리에 유지할 프로세스를 결정하는 과정 입니다.

메모리 과부화를 방지하며 효율적으로 사용할 수 있습니다.

### 단기 스케줄링

CPU 자원을 할당할 프로세스를 결정하는 과정 입니다.

메모리에 올라와 준비 큐에서 cpu 할당을 기다리는 프로세스 중에서 우선순위에 따라 선택하여 CPU를 할당합니다.

## Context Switching

컨텍스트 스위칭은 CPU를 사용할 프로세스를 교체하는 과정에서 프로세스를 실행할 정보 교체하는 기술입니다.

컨텍스트는 CPU가 프로세스를 실행하기 위한 정보들을 의미합니다.

컨텍스트는 PCB 자료구조에 저장되어 관리됩니다.

### 동작 과정

1. 스케줄러가 실행중인 프로세스를 중단하고 선택된 프로세스 실행을 요청한다.
2. 실행했던 프로세스의 ST(stack pointer)와 PC(ProgramCounter)정보를 레지스터에서 PCB로 저장한다.
3. 실행했던 프로세스와 실행할 프로세스의 상태를 변경한다. (=디스패치)
4. 새로 실행할 프로세스의 PCB 정보를 CPU 레지스터에  덮어씌운다.
![스크린샷 2023-12-28 오전 8.31.54.png](..%2F..%2F..%2F..%2F..%2F..%2F..%2Fvar%2Ffolders%2Fj2%2Flq2fjw4n0rlby3mg4xddx_mh0000gn%2FT%2FTemporaryItems%2FNSIRD_screencaptureui_wg2Y2h%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-28%20%EC%98%A4%EC%A0%84%208.31.54.png)

## PCB**(Process Control Block)**

PCB는 운영체제가 작업을 프로세스 단위로 관리할 때 사용하는 실제적인 자료구조입니다.

프로세스 상태 및 실행에 필요한 모든 정보를 담고 있습니다.

프로세스와 동일한 생명주기를 가집니다.

주요 정보는 다음과 같습니다.

![스크린샷 2023-12-28 오전 8.32.25.png](..%2F..%2F..%2F..%2F..%2F..%2F..%2Fvar%2Ffolders%2Fj2%2Flq2fjw4n0rlby3mg4xddx_mh0000gn%2FT%2FTemporaryItems%2FNSIRD_screencaptureui_RwTQDg%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-28%20%EC%98%A4%EC%A0%84%208.32.25.png)
**Pointer** : 부모 프로세스에 대한 포인터, 자식 프로세스에 대한 포인터 등의 참조 포인터

**Process State** : 프로세스의 현재 상태 (running, ready, waiting)

**Process Number** : 프로세스가 생성될 때 부여받는 고유 식별자 (indentifier)

**Program Counter** : 프로세스가 다음에 수행해야할 명령어의 주소

**Registers** : 중앙처리장치의 각종 레지스터 상태를 저장하기 위한 공간

## 스케줄링 유형

### 선점

한 프로세스가 CPU 자원을 사용하고 있을 때 다른 프로세스가 빼앗을 수 있는 스케줄링 유형입니다.

우선순위가 높은 작업을 먼저 처리할 수 있고, 특정 프로세스의 CPU 독점을 막을 수 있습니다.

다만 교체가 자주 발생할 시 컨텍스트 스위칭에 따른 오버헤드가 발생할 수 있습니다.

특정 시간 내에 응답해야하거나 우선순위 변동이 잦은 작업에 적합합니다.

예를 들어 모니터링과 같은 실시간 시스템에 사용될 수 있습니다.

### 비선점

한 프로세스가 CPU 자원을 사용하고 있을 때 다른 프로세스가 빼앗을 수 없는 스케줄링 유형입니다.

실행중인 프로세스가 스스로 종료해야 교체할 수 있습니다.

대략적인 작업 시간을 예측할 수 있고 선점형 스케줄링보다 상대적으로 오버헤드가 적습니다.

다만 빠르게 처리해야할 작업이 늦춰질 수 있고, 특정 프로세스의 CPI 점유에 의해 대기 시간이 길어질 수 있습니다.

간단한 알고리즘이나 일괄처리에 적합합니다.

## 선점형 스케줄링 주요 알고리즘

### **라운드 로빈(Round Robin)**

프로세스마다 동일한 CPU 점유시간을 가진다.

점유시간동안 작업을 마치지 못한 프로세스는 준비 큐의 가장 뒷쪽으로 넘어간다.
![스크린샷 2023-12-28 오전 8.32.53.png](..%2F..%2F..%2F..%2F..%2F..%2F..%2Fvar%2Ffolders%2Fj2%2Flq2fjw4n0rlby3mg4xddx_mh0000gn%2FT%2FTemporaryItems%2FNSIRD_screencaptureui_3AQLfX%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-28%20%EC%98%A4%EC%A0%84%208.32.53.png)

### **SRT(Shortest Remaining Time First)**

소요 시간이 짧은 프로세스 부터 먼저 수행한다.

늦게 들어왔어도 소요시간이 짧으면 먼저 실행된다.
![스크린샷 2023-12-28 오전 8.33.10.png](..%2F..%2F..%2F..%2F..%2F..%2F..%2Fvar%2Ffolders%2Fj2%2Flq2fjw4n0rlby3mg4xddx_mh0000gn%2FT%2FTemporaryItems%2FNSIRD_screencaptureui_MmEmIF%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-28%20%EC%98%A4%EC%A0%84%208.33.10.png)

## 비선점형 스케줄링 주요 알고리즘

### **FCFS(First Come First Service)**

대기 큐에 도착한 순서에 따라 CPU 할당
![스크린샷 2023-12-28 오전 8.33.26.png](..%2F..%2F..%2F..%2F..%2F..%2F..%2Fvar%2Ffolders%2Fj2%2Flq2fjw4n0rlby3mg4xddx_mh0000gn%2FT%2FTemporaryItems%2FNSIRD_screencaptureui_2QDybW%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-28%20%EC%98%A4%EC%A0%84%208.33.26.png)
### **SJF(Shortest Job First)**

- 프로세스가 도착하는 시점에 따라 그 당시 가장 짧은 소요 시간을 갖는 프로세스가 종료 시까지 CPU 점유
- CPU 요구 시간이 긴 작업과 짧은 작업 간의 불평등이 심해 기아 현상 발생 가능성

![스크린샷 2023-12-28 오전 8.33.52.png](..%2F..%2F..%2F..%2F..%2F..%2F..%2Fvar%2Ffolders%2Fj2%2Flq2fjw4n0rlby3mg4xddx_mh0000gn%2FT%2FTemporaryItems%2FNSIRD_screencaptureui_YO3GIT%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-28%20%EC%98%A4%EC%A0%84%208.33.52.png)
## 스케줄 알고리즘 성능평가 척도

| 프로세서 이용률(CPU Utilization) | 시간당 CPU를 사용한 시간의 비율 |
| --- | --- |
| 처리율(Throughput) | 단위 시간당 완료된 프로세스 수 |
| 소요시간(Turnaround Time) | 프로세스가 완료될 때까지 걸린 시간 |
| 응답시간(Response Time) | 대기열에서 처음으로 CPU를 얻을때까지 걸린시간 |

![스크린샷 2023-12-28 오전 8.34.10.png](..%2F..%2F..%2F..%2F..%2F..%2F..%2Fvar%2Ffolders%2Fj2%2Flq2fjw4n0rlby3mg4xddx_mh0000gn%2FT%2FTemporaryItems%2FNSIRD_screencaptureui_EssitG%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-28%20%EC%98%A4%EC%A0%84%208.34.10.png)

대기시간 : 프로세스가 실행 까지 걸리는 시간

응답시간 : 요청한 프로세스가 실행되어 응답을 받을 때 까지 걸리는 시간

실행시간 : 프로세스 실행 부터 종료까지 걸린 시간

반환시간 : 대기시간 + 실행시간

# 참고자료
[[OS] 프로세스를 스케줄링 하는 방법들 (Scheduling) - OS 공부 3](https://icksw.tistory.com/123)