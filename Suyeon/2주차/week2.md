### 💡 스케줄러란?

시스템에서 동작하는 여러 프로세스들 사이에 어떤 프로세스가 언제 실행될지 결정하는 역할을 한다. 

실행될 때 어떤 프로세스가 cpu의 자원을 할당받을지 등등 여러 요인을 결정하기 위한 중요한 요소이다.

크게 process 스케줄링과 thread 스케줄링으로 나뉠 수 있다

- process 스케줄링은 독립적인 프로세스 간의 cpu 할당을 스케줄링한다
- thread 스케줄링은 하나의 프로세스 안에서 동작하는 thread 간의 cpu 할당을 스케줄링한다


### 💈 스케줄러 큐

- 프로세스는 종료될 때까지 다양한 대기열에서 자기 순번을 기다리는데 이 대기열을 `스케줄러 큐`라고 합니다.
- 대표적인 스케줄러 큐는 다음과 같이 세 종류가 있습니다.

> 1️⃣ Job Queue : 시스템 내부 모든 프로세스들의 큐
> 
> 
> 2️⃣ Ready Queue : CPU 할당 대기 중인 프로세스들의 큐
> 
> 3️⃣ Device Queue(I/O Queue) : 입출력 작업을 대기 중인 프로세스들의 큐
>

### 💡 스케줄링 단계를 설명해주세요.
![image](https://github.com/CS-Entrance/Chapter1/assets/89267864/e23b7337-d4f3-4d84-a19c-3bc73dc8a5bf)

**1️⃣ 장기 스케줄링 (Long-term Scheduling)**

- 한정된 메모리에 많은 프로세스를 올릴 수 없으므로 대용량 메모리(보통 disk, 이하 pool)에 저장된다.
- pool에 저장되어 있는 프로세스 중 어떤 프로세스에 메로리를 할당하여 `ready queue`로 보낼지 결정한다
    - 프로세스 상태: new → ready (in memory)
    - `ready queue`란 메모리 내에 있으면서 CPU 할당을 기다리는 프로세스의 집합
- 메모리와 디스크 사이의 스케줄링을 담당한다
- 프로세스에 메모리 및 각종 리소스를 할당한다 (Admit)

참고)

메모리에 프로그램이 너무 많이 올라가도, 너무 적게 올라가도 성능이 좋다고 할 수 없다.

**2️⃣ 단기 스케줄링 (Short-term Scheduling || CPU Scheduling)**

- CPU와 메모리 사이의 스케줄링을 담당한다
- Ready Queue에 존재하는 프로세스 중에 어떤 프로세스를 Running 시킬지 결정한다
- 프로세스에 CPU를 할당한다 (Scheduler Dispatch)
    - 프로세스 상태: ready → running → waiting → ready

**3️⃣ 중기 스케줄링 (Medium-term Scheduling || Swapping)**

- 여유 공간을 위해 프로세스를 메모리에서 디스크로 이동시킨다 (Swapping)
- 프로세스에서 메모리를 deallocate한다
    - 프로세스 상태: ready → suspended
    - suspended 상태란 프로세스 수행이 정지된 상태로 “메모리에서 내려간 상태”를 의미한다
    - blocked 상태는 ready 상태로 돌아갈 수 있지만 suspend 상태는 외부 요인에 의해 내려간 상태라 ready 상태로 돌아갈 수 없다.
- 현 시스템에 메모리에 너무 많은 프로그램이 올라가는 것을 조절한다
    - 프로세스가 올라가는 걸 조절하는건지, 프로그램이 올라가는 걸 조절하는건지?

### 💡 스케줄링이 무엇인지와 목적을 설명해주세요

가장 궁극의 목표는 “성능 향상”이다. 이를 위해 여러 프로세스를 동시에 효율적으로 동작할 수 있도록 설정하는 것이다.

그렇다면 여러 프로세스나 쓰레드에게 자원이 할당될 때 효율적인 자원의 할당이 성능 향상을 위한 하나의 목표가 될 수 있다.

효율적인 자원의 할당을 위해서는 시스템 향상을 판단할 수 있는 지표 값을 통해 효율성을 판단하고 활용할 수 있다.

![image](https://github.com/CS-Entrance/Chapter1/assets/89267864/7b4861fd-7d13-41d5-a3b0-ccf0e243b202)

즉, 처리율과 CPU 이용률을 증가시키면서 오버헤드, 응답시간, 반환시간, 대기시간을 최소화 하기 위해서(=성능 향상) 스케줄링을 활용하는 것이다.

쉽게 말하자면 CPU가 쉬는 시간도 없이 하루~종일 일 하도록 계획표를 세워주는 것이다. (악마)

### 💡 Context Switching이 뭐에요?

여러 프로세스중 하나의 프로세스를 반환하고 다른 프로세스를 사용하기 위해 CPU의 자원을 할당하고 이전 프로세스의 상태(Context)를 PCB에 저장하는 작업이다.

PCB란 Process Control Block의 약자로 프로세스 정보를 포함하는 OS 커널의 자료구조이다. OS가 프로세스를 제어하기 위해 프로세스 정보를 저장해두는 곳이다.

OS는 빠르게 PCB에 접근하기 위해 `Process Table`을 사용하여 각 프로세스의 PCB를 관리한다.

![image](https://github.com/CS-Entrance/Chapter1/assets/89267864/4892d162-7f91-401b-b974-05d61c24b2a8)


### 💡 PCB에 저장되는 정보는 어떤 것들이 있나요?

**프로세스 스케줄링**을 위한 **Context Switching(문맥 교환)**과 **프로세스 상태 관리**를 목적으로 PCB를 사용한다.

PCB는 프로세스에 대한 정보를 가지고 있는 곳이다.

즉, 프로세스마다 고유의 정보가 있으므로 프로세스가 생성될 때 마다 고유의 PCB가 생성된다. 동시에 프로세스가 완료된다면 PCB는 제거된다.

![image](https://github.com/CS-Entrance/Chapter1/assets/89267864/e4cce512-ddff-414d-aa27-8af4f22c5f56)

위 이미지는 PCB의 구조를 나타낸다.

1. Pointer 
    1. 프로세스가 위치한 메모리 주소 포인터
    2. 부모 프로세스 포인터
    3. 자식 프로세스 포인터
    4. 할당된 자원에 대한 포인터 
2. Process State
    1. 프로세스가 현재 어떤 상태에 있는지 나타내는 정보
    2. 생성(New), 준비(Ready), 실행(Running), 대기(Waiting), 종료(Terminated)
3. Process Number(PID) ⭐
    1. 프로세스 식별자
4. Program Counter(PC) ⭐
    1. 해당 프로세스에서 다음에 실행될 명령어의 주소를 가리킨다
5. CPU 스케줄링 정보
    1. 우선 순위, 최종 실행시각, CPU 점유시간..등의 정보를 가진다
6. Registers
    1. CPU 레지스터 및 일반 레지스터 정보를 가진다
7. Memory Limits
    1. OS에서 사용하는 메모리 관리 시스템에 대한 정보를 가진다
    2. Page Table, Segement Table이 포함될 수 있다.
8. Open FIle Listss
    1. 해당 프로세스를 위해 열린 파일 목록을 가진다

### 💡 비선점방식과 선점방식을 설명해주세요.

**1️⃣ 비선점 (Non-Preemptive)**

- 우선순위와 상관없이 CPU로 부터 자원을 할당받은 경우 해당 프로세스가 반납되기 전까지 계속해서 사용할 수 있는 방식이다.
- 즉, 중간에 우선순위가 높은 프로세스가 와도 이미 자원을 할당받은 프로세스를 계속해서 실행하는 것이다.
- FCFS(First-Come First-Served), SJF(Shortest Remaining Time First), HRN(Highest Response-ratio Next)

**장점**

- 강제로 다른 프로세스가 자원을 뺴앗을 수 없으므로 선점형보다 스케줄러 호출 빈도가 낮다.
    - 빼앗기지 않아 프로세스의 응답 시간 예측이 더욱 쉽다.
- 따라서 Context Switching에 의한 오버헤드도 적게 발생한다.
- 일괄 처리 시스템에 적합하다.

**단점**

- CPU 자원 할당 시간이 긴 프로세스가 CPU 할당 시간이 짧은 다른 프로세스를 오랫동안 대기시키는 상황이 발생할 수 있다.
- 따라서, 처리율이 떨어질 수 있다.

**2️⃣ 선점 (Preemptive)**

- `우선순위`를 적용하여 우선순위가 더 높은 프로세스가 있을 경우 해당 프로세스가 CPU를 선점하게 되는 방식이다.
- 다른 프로세스가 실행중이어도 우선순위가 높은 프로세스를 우선시 한다.
- SRT(Shortest Remaining Time), RR(Round Robin), MLQ(Mulit-Level Queue)

**장점**

- 빠른 응답 시간이 필요한 대화식 시분할 시스템에 적합하다.
- 또한, 우선순위가 높은 프로세스를 빠르게 실행하여 효율성을 높일 수 있다.

**단점**

- 다만, 잦은 Context Switching이 발생하게 된다면 오버헤드가 발생할 수 있으니 유의해야 한다.
- 우선순위 역전 현상이 발생할 수 있다.
    - 공유 자원에 대한 lock때문에 발생하는 문제이다
    - 만약, 우선 순위 순서가 A>B>C인 경우가 있다고 가정해 보자.
    
    B는 다른 공유 자원을 사용하지만 A와 C는 같은 공유 자원을 사용한다. 
    C가 먼저 CPU를 할당받고 공유 자원을 사용한다면 해당 공유 자원에 lock이 걸려 다른 프로세스는 해당 공유 자원에 접근할 수 없다.
    이때, 우선 순위가 더 높은 A가 작업을 수행하려 하지만 C가 사용하는 공유 자원에 lock이 걸려 작업을 수행하지 못하고 “대기”상태가 된다.
    하지만, 공유 자원을 필요로 하지 않는 B가 작업을 수행하려 한다면 C보다 우선순위가 높으면서 lock과 상관없는 프로세스이므로 B가 CPU를 할당받게 된다.
    B가 작업을 완료하고 C에게 돌아와 작업을 완료한 후 lock이 풀릴 때 A가 수행할 수 있게 되는 “**우선순위 역전**” 현상이 발생하게 된다.
    

### 💡 Round Robin 스케줄링이 뭐에요? (=RR)

1. 선점 방식 알고리즘
2. 시분할 시스템 - 즉, 프로세스간 우선순위가 존재하지 않는다.
    1. 우선 순위가 낮은 프로세스들은 무한 대기에 걸려 작업을 하지 못하는 상황이 발생하는데 이를 해결하기 위한 기법이다.
3. 사용 제한 시간(Quantum)을 두고 할당 시간 이상은 자원을 사용하지 못하도록 함
4. 자원 독점 방지
5. 단, 짧은 Quantum 설정시 Context Switch Overhead가 발생할 수 있다
6. 대화형 시스템에 적합하다.

![image](https://github.com/CS-Entrance/Chapter1/assets/89267864/22693666-70e1-4dd8-9f27-bd07ac64d2f2)

![image](https://github.com/CS-Entrance/Chapter1/assets/89267864/e844a82c-fc2d-4329-84d3-a6ad011ca139)


위 이미지 예시에 따라 2초가 지난다면 어떤 일이 있어도 해당 프로세스는 ready queue로 돌아가 cpu 할당을 대기받게 된다.

### 💡 스케줄링 기법 중 FCFS의 단점과 해결 방법을 설명해주세요.

먼저 FCFS는 First Come First Served의 약자이다. FIFO랑 동일한 의미이다.

RR과 다르게 `비선점 방식`이며 그대로 해석하면 “**먼저 들어온 순서대로 스케줄링**” 한다는 의미이다.

즉, 우리가 화장실 줄을 기다릴 때 먼저 줄을 선 사람부터 화장실에 가는 것 처럼 스케줄링 하는 것이다.

이때 앞선 사람이 화장실 칸에 들어갔다가 금방 나오면 다행이지만..

내가 정말 급한 상황인데 앞에 사람의 볼일 보는 시간이 30분이라면..? 정말 큰일인 것이다...

이것이 바로 FCFS의 단점이다.

한 프로세스가 독점을 하는 경우 뒤에 우선순위가 높은 프로세스들이 무한 대기에 들어가게 된다. 

즉, 평균 응답 시간이 길어져 효율적이지 못하게 되는 것이다.

![image](https://github.com/CS-Entrance/Chapter1/assets/89267864/1166cfa5-c16f-4cbb-a4fc-d1b2b3de0bb5)

![image](https://github.com/CS-Entrance/Chapter1/assets/89267864/c82e2f03-8ba5-452e-aa83-0b6443c08872)

위 이미지 처럼 FCFS 알고리즘은 무조건 Busrt Time(작업 시간)을 모두 할당해야 다음 프로세스로 넘어갈 수 있다.

만약 P1의 작업 시간이 무한정으로 길다면 뒤에 도착한 프로세스들이 무한 대기 상태에 들어가 비효율적인 상태가 된다.

이를 해결하기 위해 SJF(Shortest Job First), 우선 순위 기반(Priority), Round Robin(RR), MLQ(Multi-Level Queue) 등의 여러 알고리즘이 존재한다.

이 중 FIFO와 똑같이 비선점형 스케줄링 알고리즘인 SJF를 해결방안으로 채택할 수 있다.

### SJF (=Shortest Remaining Time First)

직역하자면 “가장 적게 남은 작업 시간부터 먼저”이다.

즉, 대기하고 있는 프로세스 중 Burst Time이 가장 짧은 것 부터 먼저 작업하도록 하는 것이다.

![image](https://github.com/CS-Entrance/Chapter1/assets/89267864/93ab2ac7-fe2c-469d-b4be-f23a06a63d21)

위 SJF 간트 차트를 보면 FCFS 간트 차트와 다르게 P1이 남은 작업 시간이 많아 모든 프로세스가 완료 된 이후에 완료되는 모습을 볼 수 있다.

SJF에서도 문제가 발생할 수 있는데 이때 “**Starving(아사)**” 문제가 발생할 수 있다.

Starving이란 **소요시간이 큰 프로세스는 계속해서 실행되지 않아서 무한 대기**에 들어가는 문제이다.

또한, 운영체제가 프로세스의 작업 시간을 정확하게 예측하기 어렵다는 단점도 있다.

이런 `Starving` 문제를 해결하기 위해 `Aging`, `Priority`, `Multi-Level Queue`등 여러 방법으로 해결할 수 있다.

---

### 추가질문


**Q. 언제 스케줄링이 발생하나요 (= 언제 context swtiching이 발생하나요)**

ready 상태에 있던 프로세스가 running 상태로 변경되는 경우

외부 io 입력에 의해 running 상태에서 waiting 상태로 변경되는 경우

입출력이 끝나서 waiting 상태에서 ready 상태로 변경되는 경우



**Q. 스케줄러 vs 디스패처**

스케줄러는 OS 커널의 모듈이다. 어떤 CPU에 자원을 할당해줄지 고른다

디스패처는 프로세스를 교체시키는 기능

즉, CPU 스케줄러의 구성요소가 디스패처

참고)

context swtiching일때는 ****디스패처는 사용자 모드에서 커널 모드로 이동해서 프로세스를 교체하고 끝난다면 다시 사용자 모드로 이동한다



**Q. 오늘 날의 OS는 장기 스케줄러를 사용하지 않는이유**

시분할 프로그래밍이 적용되면서 new 단계와 동시에 ready 단계로 넘어가게 되어서 그렇다

+물리적인 메모리 용량 증가

+가상 메모리 추가



**Q. 디스크의 Swap 영역**

swapping에 대해 설명하면서 디스크의 swap 영역에 대해 알아보자



**Q. 다단계 큐 스케줄링(Multi-Level Queue) 단점**

우선순위 스케줄링의 단점을 그대로 가져온다. 

높은 우선순위의 프로세스가 들어오면 바로 해당 프로세스에 CPU를 할당해주어야 하기 때문에 기아 현상이 발생할 수 있다.

즉, 다단계 큐 스케줄링의 단점은 기아 현상을 해결 할 수 없다는 것이다.

이를 위해 다단계 피드백 큐 스케줄링(Multi-Level Feedback Queue) 알고리즘을 활용한다

해당 알고리즘을 통해 프로세스들이 큐 사이를 이동할 수 있게끔 해서 기아 현상을 해결할 수 있게 했다

새로 준비상태가 된 프로세스는 우선순위가 가장 높은 우선순위 큐에 삽입되고, 일정 시간동안 실행된 이후 해당 큐에서 실행이 끝나지 않는다면 **그 다음 우선순위 큐에 삽입되어 실행된다.**
결국 CPU를 오래 사용하는 프로세스는 점차 우선순위가 낮아진다.

또한 낮은 우선순위에서 오래 기다리고 있는 프로세스가 있다면 점차 우선순위가 높은 큐로 이동시킬 수 있다.

 

**Q. PCB와 TCB의 관계** ⭐

TCB란 Thread Control Block의 약자로 프로세스에 존재하는 `스레드 라이브러리`의 스케줄링 대상(스레드)이다

반면에, PCB는 `OS`의 스케줄러가 PCB를(프로세스) 대상으로 한다.

![image](https://github.com/CS-Entrance/Chapter1/assets/89267864/d4f2529f-9639-4931-b108-411d7e296edf)


위 이미지처럼 둘의 전체적인 구조는 외부에서 TCB가 PCB를 참조한다

TCB가 PCB보다 대적으로 적은 데이터를 가진다.

스레드끼리는 사용자 수준 문맥의 text 영역과 data 영역은 공유하나 stack 영역은 따로 갖는다

PCB는 메모리의 “커널 영역”에 있지만 TCB는 “유저 영역”과 “커널 영역”에 둘 다 있을 수 있다.

하지만, 요즘은 “유저 영역”을 거의 사용하지 않는다. 

TCB가 “커널 영역”에 있을 경우 커널에서 스레드 관련된 모든 작업(스케줄링, 실행)을 관리한다.

커널이 전체 프로세스와 스레드 정보까지 유지하게 되는 것이다.

이때 thread의 context switiching이 발생할 때 사용자 영역에서 커널 영역으로의 전환 과정이 필요하다.



**Q. 스케쥴링 중에서 프로세스 상태로 등장하지 않는 상태**

suspended 상태 (스와핑된 상태라서)



**Q. 멀티 프로세스 와 시분할 프로그래밍은 무엇이 다를까요**

CPU를 최대한 활용하자, CPU 효율 UP → `멀티 프로세스` (혼자 할 수 있는 효율성을 늘리자)

응답을 최대한 빠르게 오게하자 → `시분할 프로그래밍`

즉, 둘의 차이는 "목적"의 차이에 있음을 헷갈리지 말자! 
