# 🗃️ 메모리 관리

## ⛕ 교착 상태, Dead Lock
- 어떤 프로세스가 자원을 점유한 상태에서 **다른 프로세스가 사용 중인 자원을 필요해 무한히 기다리는 현상**입니다.
- 여러 프로세스가 경쟁하면서 유한한 자원을 공유해서 사용하기 때문에 발생합니다.
- 스프링에서 등장하는 `순환 참조`도 **일종의 데드락**으로 볼 수 있습니다.

### 🔫 교착 상태의 발동 조건
- 교착 상태가 발생하는 것은 흔치 않습니다. 특정한 조건을 만족할 때 발생합니다.
  - 상호 배제 : 한 프로세스가 하나의 자원만을 사용할 수 있다.
  - 점유와 대기 : 자원을 점유한 상태로 다른 자원을 기다린다.
  - 비선점 : 다른 프로세스가 점유 중인 자원을 뺏을 수 없다.
  - 순환 대기 : 자원을 점유한 상태로 이전(이후) 프로세스의 자원을 요구하는 상태

### ⛔️ 교착 상태 방지
- 교착 상태를 해결하는 방법은 여러가지가 존재합니다.

#### 1️⃣ 예방 기법, Prevention
- 발동 조건 중 하나를 막아서 예방하는 방법입니다. 
  - 상호 배제 제거 : 동시에 공유 자원을 사용할 수 있게 한다. 공유 자원 문제 발생
  - 점유 대기 제거 : 프로세스가 실행되기 전 모든 자원을 할당해서 대기를 없앤다. 혹은 어떤 자원도 점유하지 않을 때 자원을 요구하도록 한다. 효율적이지 않고 기아 현상을 유발한다.
  - 비선점 제거 : 점유하던 자원을 뺏는 것을 허용한다.
  - 순환 대기 제거 : 한쪽 방향으로만 자원을 요구하도록 해서 원형 꼬리물기를 방지한다.
- 자원 낭비가 심하다는 단점이 있습니다.

#### 2️⃣ 회복 기법, Recovery
- 교착 상태를 일으킨 프로세스를 종료시키거나 교착 상태의 프로세스에 할당된 자원을 선점하여 자원(or 프로세스)를 회복시키는 방법입니다.
  - 프로세스 종료 : 교착 상태의 모든 프로세스를 제거하거나 하나씩 제거합니다.
  - 자원 선점 : 교착 상태의 프로세스의 자원을 다른 프로세스에게 넘겨주고 해당 프로세스를 일시정지 시킵니다.
- 교착 상태의 프로세스를 추적하기 위해서 특별한 알고리즘이 필요합니다. ([탐지 알고리즘](#-교착-상태-탐지-알고리즘))

#### 3️⃣ 회피 기법, Avoidance
- 교착 상태의 발생 가능성을 인정하고, 발생하면 피해나가는 방법입니다.
- 주로 은행원 알고리즘이 사용되며, 100% 안전한 상태가 보장될 경우에만 자원을 할당합니다.
- 상태를 판단하기 위해서 추가적인 정보를 받아야 합니다.
- 추가적인 정보를 필요로 하고, 모든 상황이 예측과 동일하다는 보장이 없기 때문에 **현실적으로 어려운 방법**입니다.

##### 은행원 알고리즘
- 대표적인 교착 상태 회피 알고리즘입니다. 
- 교착 상태에 빠질 수 있는 상태를 `안전 상태`와 `불안전 상태`로 나눠서 관리합니다.
- **은행은 최소한 한 명에게 대출해줄 수 있는 금액을 항상 보유하고 있어야 한다**는 개념에서 등장했습니다.

![출처: https://velog.io/@seorim0801/%EC%9D%80%ED%96%89%EC%9B%90-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98](은행원_알고리즘.png)

- 그림과 같은 상황에서 은행은 25원이 남아서 다음과 같은 순서로 처리할 수 있습니다.
  1. 고객1 -> 고객2 -> 고객3
  2. 고객2 -> 고객1 -> 고객3
  3. 고객2 -> 고객3 -> 고객1
- 3번 고객부터 돈을 준다면, 고객의 요구사항을 만족하지 못하면서 **어떤 자원을 할당할 수도, 돌려받을 수도 없는 상태**가 됩니다.
- 이렇게 자원을 안정적으로 돌려받을 수 없으면 `불안전 상태`라고 부릅니다. 반대로, 받을 수 있다면 `안전 상태`라고 합니다.

### 🕵️ 교착 상태 탐지 알고리즘
